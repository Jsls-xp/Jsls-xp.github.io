---
title: "Kotlin扩展函数"
date: 2025-02-22
categories: [Android, Kotlin]
tag: [扩展]
toc: false
---

## 一、扩展函数
### 1.1 扩展函数概念
扩展函数，简单来说就是一个类的成员函数，只不过是定义在类的外面，形如类名.方法名()的形式。

在扩展函数中可以直接访问被扩展类的其他方法和属性，就好像在这个类自己的方法中访问它们一样，但是不能访问私有的或者是受保护的成员。
```kotlin
fun main() {
    Person().test()

    println(Person().getSex())//输出sex，而不是Person.getSex()
}

fun Person.test() {
    this.name
    name

    this.getSex()
    getSex()

    //sex //提示Cannot access 'sex': it is private in 'Person'
    //getTest() //提示Cannot access 'getTest': it is protected in 'Person'
}

fun Person.getSex(): String{
    return "Person.getSex()"
}

open class Person{
    val name = "Person"
    private val sex = "sex"
    private val age = 0

    fun getSex(): String {
        return sex
    }

    protected fun getTest(){

    }
}
```

```java
public class Person {
   @NotNull
   private final String name = "Person";
   @NotNull
   private final String sex = "sex";
   private final int age;

   @NotNull
   public final String getName() {
      return this.name;
   }

   @NotNull
   public final String getSex() {
      return this.sex;
   }

   protected final void getTest() {
   }
}

// TestKt.java
blic final class TestKt {
   public static final void main() {
      test(new Person());
      String var0 = (new Person()).getSex();
      System.out.println(var0);
   }

   public static final void test(@NotNull Person $this$test) {
      Intrinsics.checkNotNullParameter($this$test, "<this>");
      $this$test.getName();
      $this$test.getName();
      $this$test.getSex();
      $this$test.getSex();
   }

   @NotNull
   public static final String getSex(@NotNull Person $this$getSex) {
      Intrinsics.checkNotNullParameter($this$getSex, "<this>");
      return "Person.getSex()";
   }

   // $FF: synthetic method
   public static void main(String[] args) {
      main();
   }
}
```
通过Java代码可以发现扩展函数实质上就是一个工具方法，并不会对原先的类进行修改添加新方法。所以当扩展函数跟原类里的函数重名且参数相同时，扩展函数就会失效，调用的是原先类的函数。

### 1.2 扩展函数不具备多态性
```kotlin
open class Base

class Student: Base()

fun Base.foo() = println("Base.foo()")
fun Student.foo() = println("Student.foo()")

fun executeFoo(base: Base) = base.foo()

fun main() {
    executeFoo(Base())//Base.foo()

    executeFoo(Student())//Base.foo()
}
``` 

### 1.3 Java调用Kotlin的扩展函数
Java调用Kotlin的扩展函数是这样使用的：文件名Kt.方法名(扩展类对象)
```java
    public static void main(String[] args) {
        TestKt.test(new Person());
    }
```

### 1.4 可空接收者
可以为可空的接收者类型定义扩展。
```kotlin
fun Any?.toString(): String {
    if (this == null) return "null"
    // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()
    // 解析为 Any 类的成员函数
    return toString()
}
```

总之：
* 扩展函数本质上并不是原先类新增的一个方法，它是以静态导入的方式来实现的
* 扩展函数跟原先的函数重名，并且参数都一样时，扩展函数会失效，调用的依然是原先的函数
* 扩展函数不具备多态性
* Java调用Kotlin的扩展函数时，可以把它当成是一个工具类来使用

## 二、扩展属性
扩展属性必须定义getter函数
```kotlin
class Test {
    val String.lastChar: Char
        get() = get(length - 1)
    val String.myStr: String
        get() = this + "str"

    var StringBuilder.lastChar: Char
        get() = get(length - 1)
        set(value) {
            setCharAt(length - 1, value)
        }
}
```

## 三、扩展函数其他特性
### 3.1 伴生对象的扩展
```kotlin
class MyClass {
    companion object { }  // 将被称为 "Companion"
}

fun MyClass.Companion.printCompanion() { println("companion") }

fun main() {
    MyClass.printCompanion()
}
```

### 3.2 扩展的作用域
大多数情况都在顶层定义扩展---直接在包里：
```kotlin
package org.example.declarations

fun List<String>.getLongestString() { /*……*/}
```
如需使用所定义包之外的一个扩展，只需在调用方导入它：
```kotlin
package org.example.usage

import org.example.declarations.getLongestString//导包

fun main() {
    val list = listOf("red", "green", "blue")
    list.getLongestString()
}
```

### 3.3 扩展声明为成员
在一个类内部为另一个类声明扩展，在这样的扩展内部，有多个隐式接收者---其中的对象成员可以无需通过限定符访问。扩展声明所在的类的实例称为分发接收者，扩展方法调用所在的接收者类型的实例称为扩展接收者。  
在类中声明的另一个类的扩展函数，另一个类只能在此类中来调用，另一个类在此类外部无法调用。
```kotlin
class Host(val hostname: String) {
    fun printHostname() { print(hostname) }
}

class Connection(val host: Host, val port: Int) {
    fun printPort() { print(port) }

    fun Host.printConnectionString() {
         printHostname()   // 调用 Host.printHostname()
         printPort()   // 调用 Connection.printPort()
    }

    fun connect() {
         host.printConnectionString()   // 调用扩展函数
    }
}

fun main() {
    Connection(Host("kotl.in"), 443).connect()
    //Host("kotl.in").printConnectionString()  // 错误，该扩展函数在 Connection 外不可用
}
```
其中，对于分发接收者与扩展接收者的成员名字冲突的情况，扩展接收者优先。要引用分发接收者的成员你可以使用 限定的 this 语法。
```kotlin
class Connection {
    fun Host.getConnectionString() {
        toString()         // 调用 Host.toString()
        this@Connection.toString()  // 调用 Connection.toString()
    }
}
```
Google在Android系统源码中喜欢用此语法：
```koclass Student {
    fun Person.doWork(){

    }
}

class Person {

}

class Test {

    fun Person.otherFun(){

        with(Student()){
            doWork()//在Student类中，同时本身就是在Person的扩展方法中，就能调用到doWork()。相当于在Student类中通过Person来调用的
            this@otherFun.doWork()
        }

        //Person().doWork() 调用不到
        //Student().doWork() 调用不到
    }

    fun Student.otherFun(){
        with(Person()){
            doWork()
            this.doWork()
        }
    }
}
```
