---
title: "Kotlin单例"
date: 2025-03-01
categories: [Android, Kotlin]
tag: [Kotlin单例]
toc: false
---

## 一、饿汉式
在类初始化时直接创建实例对象，不管你是否需要这个对象都会创建。  
在类加载期间初始化静态实例,保证 instance 实例的创建是线程安全的 ( 实例在类加载时实例化，有JVM保证线程安全).  
​特点: 不支持延迟加载实例(懒加载) , 此中方式类加载比较慢，但是获取实例对象比较快。  
​问题: 该对象足够大的话，而一直没有使用就会造成内存的浪费。
```java
public class Singleton_01 {

    //1. 私有构造方法
    private Singleton_01(){

    }

    //2. 在本类中创建私有静态的全局对象
    private static Singleton_01 instance = new Singleton_01();

    //3. 提供一个全局访问点,供外部获取单例对象
    public static  Singleton_01 getInstance(){
        return instance;
    }

}
```

```kotlin
object Singleton_01{
    
}
```

## 二、懒汉式
### 2.1 线程不安全
```java
public class Singleton_02 {
    //1. 私有构造方法
    private Singleton_02(){

    }

    //2. 在本类中创建私有静态的全局对象
    private static Singleton_02 instance;

    //3. 通过判断对象是否被初始化,来选择是否创建对象
    public static  Singleton_02 getInstance(){
        if(instance == null){
            instance = new Singleton_02();
        }
        return instance;
    }

}
```

```kotlin
//方式一、构造方法无参数
class Singleton_02 private constructor(){
    companion object{
        val instance: Singleton_02 by lazy { Singleton_02() }
    }
}

//方式二、构造方法携带参数
class Singleton_02 private constructor(id: String){
    companion object{
        private var mInstance: Singleton_02? = null
 
        fun getInstance(id: String): Singleton_02{
            return mInstance ?: Singleton_02(id).also { mInstance = it }
        }
    }
}
```

### 2.2 线程安全1.0-synchronzed
给 getInstance() 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。
```java
//Java实现
public class Singleton {
    private static Singleton instance;
    private Singleton(){}
    public static synchronized Singleton getInstance(){
        if(instance==null){
            instance=new Singleton();
        }
        return instance;
    }
}
```

```kotlin
//kotlin实现
方式一、构造函数无参数
class Singleton private constructor(){
    companion object{
        private val mInstance: Singleton by lazy { Singleton() }
 
        @Synchronized
        fun getInstance(): Singleton{
            return mInstance
        }
    }
}
方式二、构造函数有参数
class Singleton private constructor(id: String){
    companion object{
        private var mInstance: Singleton? = null
 
        @Synchronized
        fun getInstance(id: String): Singleton{
            return mInstance ?: Singleton(id).also { mInstance = it }
        }
    }
}
```

### 2.3线程安全2.0-双重校验锁模式
```java
//Java实现
public class Singleton {
    private static Singleton instance;
    private Singleton(){}
    public static Singleton getInstance(){
        if(instance==null){
            synchronized (Singleton.class){
                if(instance==null){
                    instance=new Singleton();
                }
            }
        }
        return instance;
    }
}
```

```kotlin
 //方式一、构造函数无参数
class Singleton private constructor(){
    companion object{
        val instance: Singleton by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) {
        Singleton() }
    }
}
//方式二、构造函数有参数
class Singleton private constructor(id: String){
    companion object{
        private var mInstance: Singleton? = null
 
        fun getInstance(id: String): Singleton{
            return mInstance?: synchronized(this){
                mInstance?: Singleton(id).also { mInstance = it }
            }
        }
    }
}
```
## 三、静态内部类

```java
/*
* 在内部类被加载和初始化时，才创建INSTANCE实例对象
* 静态内部类不会自动随着外部类的加载和初始化而初始化，它是要单独去加载和初始化的。
* 因为是在内部类加载和初始化时，创建的，因此是线程安全的
*/
public class Singleton6 {
    private Singleton6(){
        
    }
    private static class Inner{
        private static final Singleton6 INSTANCE = new Singleton6();
    }
    
    public static Singleton6 getInstance(){
        return Inner.INSTANCE;
    }
}
```

```kotlin
class Singleton6 private constructor(){
    private object Inner{
        val INSTANCE= Singleton6()
    }

    companion object {
        val instance = Inner.INSTANCE
    }
}
```
https://blog.csdn.net/yufumatou/article/details/108802446
