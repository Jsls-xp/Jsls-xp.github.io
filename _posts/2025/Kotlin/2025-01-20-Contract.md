---
title: "Contract契约"
date: 2025-01-20
categories: [Android, Kotlin]
tag: [Contract契约]
toc: false
---

## 一、背景
```kotlin
fun String?.isNotNull(): Boolean {
    return this != null && this.isNotEmpty()
}

fun printLength(s: String?=null) {
    if (!s.isNotNull()) {
        println(s.length) // Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?
    }

}
```
编译器在处理s.length时，会将 s 推断成value-parameter s: String? = ...并不一定是非空的类型。智能推断失效了，代码也无法编译。
如果做如下修改即可编译成功：
```kotlin
fun printLength(s:String?=null) {
    if (!s.isNullOrEmpty()) {
        println(s.length)
    }
}
```
其中isNullOrEmpty() 是 Kotlin 标准库中 String 的扩展函数，其源码如下，其中包含了contract函数，实际上它会告诉编译器当 isNullOrEmpty() 返回 false 时，则 isNullOrEmpty != null 成立，因此 printLength() 函数中的变量 s 不会为 null。   
通过契约，开发者可以向编译器提供有关函数的行为，以帮助编译器对代码执行更完整的分析。契约就像是开发者和编译器沟通的桥梁，但是编译器必须无条件地遵守契约。
```kotlin
@kotlin.internal.InlineOnly
public inline fun CharSequence?.isNullOrEmpty(): Boolean {
    contract {
        returns(false) implies (this@isNullOrEmpty != null)
    }

    return this == null || this.length == 0
}
```
Contract 是 Kotlin1.3 的新特性，在 Kotlin 1.4 中，对于 Contract 有两项改进：
* 支持使用内联特化的函数来实现契约；
* Kotlin 1.3 不能为成员函数添加 Contract，从 Kotlin 1.4 开始支持为 final 类型的成员函数添加 Contract（当然任意成员函数可能存在被覆写的问题，因而不能添加）。


## 二、Contract源码
### Contract特性
* 只能在 top-level 函数体内使用 Contract，不能在成员和类函数上使用它们。
* Contract 所调用的声明必须是函数体内第一条语句。
* 目前 Kotlin 编译器并不会验证 Contract，因此开发者有责任编写正确合理的 Contract。

Contract 采用 DSL 方式进行声明，Contract() 函数的源码为：
```kotlin
@ContractsDsl
@ExperimentalContracts
@InlineOnly
@SinceKotlin("1.3")
@Suppress("UNUSED_PARAMETER")
public inline fun contract(builder: ContractBuilder.() -> Unit) { }
```
通过 ContractBuilder 构建了 Contract，其源码如下：
```kotlin
@ContractsDsl
@ExperimentalContracts
@SinceKotlin("1.3")
public interface ContractBuilder {
    /**
     * Describes a situation when a function returns normally, without any exceptions thrown.
     *
     * Use [SimpleEffect.implies] function to describe a conditional effect that happens in such case.
     *
     */
    // @sample samples.contracts.returnsContract
    @ContractsDsl public fun returns(): Returns

    /**
     * Describes a situation when a function returns normally with the specified return [value].
     *
     * The possible values of [value] are limited to `true`, `false` or `null`.
     *
     * Use [SimpleEffect.implies] function to describe a conditional effect that happens in such case.
     *
     */
    // @sample samples.contracts.returnsTrueContract
    // @sample samples.contracts.returnsFalseContract
    // @sample samples.contracts.returnsNullContract
    @ContractsDsl public fun returns(value: Any?): Returns

    /**
     * Describes a situation when a function returns normally with any value that is not `null`.
     *
     * Use [SimpleEffect.implies] function to describe a conditional effect that happens in such case.
     *
     */
    // @sample samples.contracts.returnsNotNullContract
    @ContractsDsl public fun returnsNotNull(): ReturnsNotNull

    /**
     * Specifies that the function parameter [lambda] is invoked in place.
     *
     * This contract specifies that:
     * 1. the function [lambda] can only be invoked during the call of the owner function,
     *  and it won't be invoked after that owner function call is completed;
     * 2. _(optionally)_ the function [lambda] is invoked the amount of times specified by the [kind] parameter,
     *  see the [InvocationKind] enum for possible values.
     *
     * A function declaring the `callsInPlace` effect must be _inline_.
     *
     */
    /* @sample samples.contracts.callsInPlaceAtMostOnceContract
    * @sample samples.contracts.callsInPlaceAtLeastOnceContract
    * @sample samples.contracts.callsInPlaceExactlyOnceContract
    * @sample samples.contracts.callsInPlaceUnknownContract
    */
    @ContractsDsl public fun <R> callsInPlace(lambda: Function<R>, kind: InvocationKind = InvocationKind.UNKNOWN): CallsInPlace
}
```
returns()、returnsNotNull()、callsInPlace() 分别返回 Returns、ReturnsNotNull、CallsInPlace 对象，这些对象最终都实现了 Effect 接口，目前 Kotlin 只支持有 4 种 Effect：
* Returns： 表示函数成功返回，不会不引发异常。
* ReturnsNotNull：表示函数成功返回不为 null 的值。
* ConditionalEffect：表示一个效果和一个布尔表达式的组合，如果触发了效果，则保证为true。
* CallsInPlace：表示对传递的 lambda 参数的调用位置和调用次数的约束。

```kotlin
/**
 * Represents an effect of a function invocation,
 * either directly observable, such as the function returning normally,
 * or a side-effect, such as the function's lambda parameter being called in place.
 *
 * The inheritors are used in [ContractBuilder] to describe the contract of a function.
 *
 * @see ConditionalEffect
 * @see SimpleEffect
 * @see CallsInPlace
 */
@ContractsDsl
@ExperimentalContracts
@SinceKotlin("1.3")
public interface Effect

/**
 * An effect of some condition being true after observing another effect of a function.
 *
 * This effect is specified in the `contract { }` block by attaching a boolean expression
 * to another [SimpleEffect] effect with the function [SimpleEffect.implies].
 */
@ContractsDsl
@ExperimentalContracts
@SinceKotlin("1.3")
public interface ConditionalEffect : Effect

/**
 * An effect that can be observed after a function invocation.
 *
 * @see ContractBuilder.returns
 * @see ContractBuilder.returnsNotNull
 */
@ContractsDsl
@ExperimentalContracts
@SinceKotlin("1.3")
public interface SimpleEffect : Effect {
    /**
     * Specifies that this effect, when observed, guarantees [booleanExpression] to be true.
     *
     * Note: [booleanExpression] can accept only a subset of boolean expressions,
     * where a function parameter or receiver (`this`) undergoes
     * - true of false checks, in case if the parameter or receiver is `Boolean`;
     * - null-checks (`== null`, `!= null`);
     * - instance-checks (`is`, `!is`);
     * - a combination of the above with the help of logic operators (`&&`, `||`, `!`).
     */
    @ContractsDsl
    @ExperimentalContracts
    public infix fun implies(booleanExpression: Boolean): ConditionalEffect
}

/**
 * Describes a situation when a function returns normally with a given return value.
 *
 * @see ContractBuilder.returns
 */
@ContractsDsl
@ExperimentalContracts
@SinceKotlin("1.3")
public interface Returns : SimpleEffect

/**
 * Describes a situation when a function returns normally with any non-null return value.
 *
 * @see ContractBuilder.returnsNotNull
 */
@ContractsDsl
@ExperimentalContracts
@SinceKotlin("1.3")
public interface ReturnsNotNull : SimpleEffect

/**
 * An effect of calling a functional parameter in place.
 *
 * A function is said to call its functional parameter in place, if the functional parameter is only invoked
 * while the execution has not been returned from the function, and the functional parameter cannot be
 * invoked after the function is completed.
 *
 * @see ContractBuilder.callsInPlace
 */
@ContractsDsl
@ExperimentalContracts
@SinceKotlin("1.3")
public interface CallsInPlace : Effect
```

## 三、总结
综上源码可得，Contract 有两种类型：Returns和CallInPlace。
### 3.1 Returns Contracts
Returns Contracts 有以下几种形式：
* returns() implies
* returns(true) implies
* returns(false) implies
* returns(null) implies
* returnsNotNull() implies
表示当 return 的返回值是某个值（例如true、false、null）时，implies后面的条件成立；returns() implies 表示当该函数正常返回时，implies后面的条件成立。

### 3.2 CallInPlace Contracts
callsInPlace(lambda: Function<R>, kind: InvocationKind = InvocationKind.UNKNOWN) 中的 InvocationKind 是一个枚举类，包含如下的枚举值：
* AT_MOST_ONCE：函数参数将被调用一次或根本不调用。
* EXACTLY_ONCE：函数参数将只被调用一次。
* AT_LEAST_ONCE：函数参数将被调用一次或多次。
* UNKNOWN：一个函数参数它可以被调用的次数未知。

如let函数的源码会告知编译器，lambda 表达式 block 在 let 函数内只会执行一次。
```kotlin
@kotlin.internal.InlineOnly
public inline fun <T, R> T.let(block: (T) -> R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return block(this)
}
```

>callsInPlace() 允许开发者提供对调用的 lambda 表达式进行时间/位置/频率上的约束。
